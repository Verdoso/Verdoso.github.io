<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on GreenEyed's</title><link>https://www.greeneyed.org/tags/java/</link><description>Recent content in Java on GreenEyed's</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 02 Dec 2022 13:45:03 +0000</lastBuildDate><atom:link href="https://www.greeneyed.org/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>On Java (virtual) threads and pools</title><link>https://www.greeneyed.org/post/virtual-threads/</link><pubDate>Fri, 02 Dec 2022 13:45:03 +0000</pubDate><guid>https://www.greeneyed.org/post/virtual-threads/</guid><description>Much has already been written about the new feature known as virtual threads, introduced as a preview in Java 19, and about the changes that this feature will enable. Among those, we can find that the new virtual threads are light, as opposed to the regular ones tied to native threads, so there is no need to cache or pool them. So far, so good.
Native threads are considered heavy, so you can create a limited number of them, but virtual threads are light so they are virtually, pun intended, limitless.</description></item><item><title>Spring Boot JSON API versioning options</title><link>https://www.greeneyed.org/post/spring-boot-json-api-versioning/</link><pubDate>Mon, 09 Sep 2019 16:15:34 +0000</pubDate><guid>https://www.greeneyed.org/post/spring-boot-json-api-versioning/</guid><description>One of the common issues when developing an API specification is how to deal with API contract modifications. Hopefully one is very successful and has lots of customers with software clients already using the current version of the spec. so simply dropping the existing version and moving to the new one is not an option, hence the issue.
Spring Boot, with its automatic JSON mapping with Jackson, is a very productive framework to develop APIs, but one still has to face the problem on how to adapt the code to support several API versions with the same code base.</description></item><item><title>XML/XSLT 3.0 development with Spring Boot, Saxon and Summer</title><link>https://www.greeneyed.org/post/xml-xslt-3-0-development-with-spring-boot-saxon-and-summer/</link><pubDate>Sat, 27 Jul 2019 16:34:09 +0200</pubDate><guid>https://www.greeneyed.org/post/xml-xslt-3-0-development-with-spring-boot-saxon-and-summer/</guid><description>(Image by James Osborne from Pixabay)
In this entry, I am going to explain how you can develop web applications using Spring Boot using XSLT 3.0 as a view technology. The XSLT 3.0 processor I’m going to be using is Saxon as that is the only working Java implementation I’m aware of. To facilitate development, I will add my own library to the mix, GreenSummer, because it’s the one I’m most familiar with.</description></item><item><title>Real life Java: From numbers to localized text ordinals using ICU4J</title><link>https://www.greeneyed.org/post/real-life-java-from-numbers-to-localized-text-ordinals-using-icu4j/</link><pubDate>Tue, 17 Jul 2018 18:18:44 +0200</pubDate><guid>https://www.greeneyed.org/post/real-life-java-from-numbers-to-localized-text-ordinals-using-icu4j/</guid><description>Recently, I had to build a Java application that reads a series of data and puts “human readable” labels on it. Some of the texts the application has to generate use ordinals like “This is the **_first _**report…” and they have to be displayed in three different languages, so instead of using a non-scalable solution (if/else, switch), I decided to generate the messages from the numeric data using something more flexible.</description></item><item><title>Real life Java: Aggregating nested collection with streams</title><link>https://www.greeneyed.org/post/real-life-java-aggregating-nested-collection-with-streams/</link><pubDate>Fri, 08 Jun 2018 18:13:25 +0200</pubDate><guid>https://www.greeneyed.org/post/real-life-java-aggregating-nested-collection-with-streams/</guid><description>Most of the times I had used the “relatively new” streams in Java, it was for straight-forward tasks with operations on one stream. I sometimes use more sophisticated collectors, like Collectors.toMap, but recently I had to use more complicated stuff to solve a real problem and I thought it might interesting writing about it, as the examples one usually reads about are synthetic and lack the focus of solving a real problem.</description></item><item><title>Spring Boot: Setting a unique ID per request</title><link>https://www.greeneyed.org/post/spring-boot-setting-a-unique-id-per-request/</link><pubDate>Thu, 22 Feb 2018 21:20:18 +0100</pubDate><guid>https://www.greeneyed.org/post/spring-boot-setting-a-unique-id-per-request/</guid><description>Spring Boot web applications, like many others unless you go for the mono-threaded option (yuck!) serve requests concurrently. That brings many advantages, but one of the drawbacks that come with it is that it makes harder to trace what each request is doing, as it is doing it while other requests are doing other, often similar, things. That hurts logging information badly, as the messages generated for one request can easily be intermingled with other messages generated for other requests.</description></item><item><title>Configuring Multiple TTL Caches in Spring Boot dinamically</title><link>https://www.greeneyed.org/post/configuring-multiple-ttl-caches-in-spring-boot-dinamically/</link><pubDate>Mon, 16 Oct 2017 21:09:38 +0200</pubDate><guid>https://www.greeneyed.org/post/configuring-multiple-ttl-caches-in-spring-boot-dinamically/</guid><description>Recently, I started using Spring caching in my Spring Boot applications and I came across a very nice entry in Daniel Olszewski’s blog (MULTIPLE TTL CACHES IN SPRING BOOT) that indeed explains how to set up multiple caches in Spring Boot with a specified TTL (Time To Live) setting and is really worth reading it as it even explains how to test the functionality. So, if you have not read it already, I invite you to do go ahead and do it now, as I’ll build on top of that.</description></item><item><title>X-Factor Apps using the Spring Boot ecosystem, an overview</title><link>https://www.greeneyed.org/post/x-factor-apps-using-the-spring-boot-ecosystem-an-overview/</link><pubDate>Sun, 08 Oct 2017 00:00:00 +0200</pubDate><guid>https://www.greeneyed.org/post/x-factor-apps-using-the-spring-boot-ecosystem-an-overview/</guid><description>Summary Nowadays, there are tons of literature and virtual ink written about how to develop for the cloud and make your applications Internet-scale. But how about those of us where the scale of our problems do not fit such model? Well, even if you are not developing for the cloud and you don’t need to go full scale with the Twelve-Factor App recommendations, there are still many benefits that can still be enjoyed by sticking to the main principles behind them.</description></item><item><title>Spring Boot, MyBatis, multiple datasources and multiple mappers, all together holding hands</title><link>https://www.greeneyed.org/post/spring-boot-mybatis-multiple-datasources/</link><pubDate>Mon, 22 May 2017 22:00:00 +0000</pubDate><guid>https://www.greeneyed.org/post/spring-boot-mybatis-multiple-datasources/</guid><description>One of the issues with Spring Boot that I have come across a couple of times and that are usually a bit painful to solve is how to configure multiple datasources and mappers with MyBatis. I have always had to browse the web, check different sources and try different examples while fighting unclear error messages until I get it right. And then the next time configuration has changed in some subtle way either in MyBatis or Spring Boot and it’s all over again.</description></item></channel></rss>